#
#          -. .-.   .-. .-.   .-. .-.   .
#            \   \ /   \   \ /   \   \ /
#           / \   \   / \   \   / \   \
#          ~   `-~ `-`   `-~ `-`   `-~ `-
	        GENOME ANALYSIS
	  
Genetic code analyzer specification & implementation guide


*** NOTE: This file is better viewed using emacs in org-mode (M-x org-mode)

* 0. Introduction:
------------------

The purpose is to implement a set of analyses which can provide a deep insight on the content of very large genetic codes.

There are two possible approaches:


      Approach 1:
			LOAD DATA ==> PROCESS DATA ==> GENERATE OUTPUT
			
      Approach 2:
			PRE-PROCESS DATA ==> GENERATE NEW DATA FORMAT
      	       		LOAD DATA IN THE NEW FORMAT ==> PROCESS DATA ==> GENERATE OUTPUT

In the first approach, the programm will have to handle reformatting/compressing the data in the PROCESS DATA phase.
On the other hand, for the second approach, a formatting script, or another program, will have to prepare the data and format it before
the PROCESS DATA phase. This adds pre-processing overhead but can drastically speed up the processing if the format is adequately designed. 


** A little bit of genetics:
----------------------------

The basic components of a genetic sequence are called nucleotides:

    A = Adenine
    T = Thymine
    C = Cytosine
    G = Guanine
    U = Uracil
    
These nucleotides are put together in blocks of 3 called codons. Each codon represents an amino acid, the basic block
of a protein. There are 4 possible values for each position in the codon allowing for a total of 4 * 4 * 4 = 64 possible combinations,
but there are only 21 active amino acids. See below (Codon;ShortName;Symbol;FullName):

AAA;Lys;K;Lysine
AAC;Asn;N;Asparagine
AAG;Lys;K;Lysine
AAU;Asn;N;Asparagine
ACA;Thr;T;Threonine
ACC;Thr;T;Threonine
ACG;Thr;T;Threonine
ACU;Thr;T;Threonine
AGA;Arg;R;Arginine
AGC;Ser;S;Serine
AGG;Arg;R;Arginine
AGU;Ser;S;Serine
AUA;Ile;I;Isoleucine
AUC;Ile;I;Isoleucine
AUU;Ile;I;Isoleucine
CAA;Gln;Q;Glutamine
CAC;His;H;Histidine
CAG;Gln;Q;Glutamine
CAU;His;H;Histidine
CCA;Pro;P;Proline
CCC;Pro;P;Proline
CCG;Pro;P;Proline
CCU;Pro;P;Proline
CGA;Arg;R;Arginine
CGC;Arg;R;Arginine
CGG;Arg;R;Arginine
CGU;Arg;R;Arginine
CUA;Leu;L;Leucine
CUC;Leu;L;Leucine
CUG;Leu;L;Leucine
CUU;Leu;L;Leucine
GAA;Glu;E;Glutamic_acid
GAC;Asp;D;Aspartic_acid
GAG;Glu;E;Glutamic_acid
GAU;Asp;D;Aspartic_acid
GCA;Ala;A;Alanine
GCC;Ala;A;Alanine
GCG;Ala;A;Alanine
GCU;Ala;A;Alanine
GGA;Gly;G;Glycine
GGC;Gly;G;Glycine
GGG;Gly;G;Glycine
GGU;Gly;G;Glycine
GUA;Val;V;Valine
GUC;Val;V;Valine
GUG;Val;V;Valine
GUU;Val;V;Valine
UAC;Tyr;Y;Tyrosine
UAU;Tyr;Y;Tyrosine
UCA;Ser;S;Serine
UCC;Ser;S;Serine
UCG;Ser;S;Serine
UCU;Ser;S;Serine
UGC;Cys;C;Cysteine
UGG;Trp;W;Tryptophan
UGU;Cys;C;Cysteine
UUA;Leu;L;Leucine
UUC;Phe;F;Phenylalanine
UUG;Leu;L;Leucine
UUU;Phe;F;Phenylalanine

==> AUG;Met;M;Methionine
==> UAA;Stp;O;Stop
==> UAG;Stp;O;Stop
==> UGA;Stp;O;Stop


* 1. Loading the sequences and compression:
-------------------------------------------

   The sequences come in two formats:

       - RAW	 : a sequence of nucleotides
       - FASTA	 : (https://en.wikipedia.org/wiki/FASTA_format)

   The input file format should be specified as a parameter to the program (i.e. -i RAW or -i FASTA or --raw or --fasta).

   Once the base sequence is loaded from a file, it can either be compressed using a 2 bits encoding per base or kept
   as is (a string of 8 bit characters).

   The proposed binary encoding is the following:
   
   	A   : 00
	T/U : 11
	C   : 10
	G   : 01

   This allows to store 4 bases in a byte. For an original sequence of 1 GiBase (or 1 GiByte) this encoding will yield a
   compressed sequence of 1 GiByte / 4 = 256 MiByte.


						1 byte
						  |
					          V						  
   	      Before compression	      :	  ATGC     GTGG     GTAG     (12 Bytes)

	      After ompression		      : 00110110 01110101 01110001   (3 Bytes) 
	      	    			      	\______/
						 1 byte
	      	    			      	 8 bits
						 
   It's up to you to choose whether the program should operate on the compressed data array or on the original data format.
   Working on the compressed data will most likely allow for a much better processing speed & bandwidth, but will definitely
   require extraction/conversion operations at some point.

   Example:
   
   Suppose we want to compare these two sequences and compute the hamming distance:

		S0: ATGC GGGC CCTA
		S1: ATCC GTCC CATA

   If the bases are stored as bytes this will require 12 XOR op√©rations.
   If the the sequences are compressed, the number of XOR operations goes down to 3.
   Also, the compressed format will also greatly benefit from vectorization. With a vector register of 256bits (32 bytes),
   32 bases can be stored using the byte sequence format. Using the compressed format, 128 bases can be stored in the same register. 

   You get the point, I guess :) [as much as possible, as fast as possible]

   Data layout is key to good performance and easy optimizations (vectorization, parallelism, ...).

* 2. Processing:
----------------
	     
** 2.0 Detecting genes:

	    Genes are defined as a sequence starting with AUG (Start codon - methionine) and ending with a stop codon (UAA, UAG, UGA).
	    The program must build a gene map using the input sequence. Each entry in the map stores a couple (start position, stop position).

#+BEGIN_SRC c

//
struct gene_map_s {

   //
   unsigned long long genes_counter;

   //Gene start position (AUG)
   unsigned long long gene_start[MAX_GENES];

   //Gene stop position (UAA, UAG, UGA)
   unsigned long long gene_end[MAX_GENES];

};

gene_map_s gene_map;

Algorithm:

  start_pos = lookup(AUG, seq);
  stop_pos  = lookup(UAA or UAG or UGA, seq + start_pos);
      
  if (start_pos && stop_pos)
  {
    gene_map.gene_start[gene_map.genes_counter) = start_pos;
    gene_map.gene_stop[gene_map.genes_counter) = stop_pos;

    gene_map.genes_counter++;
  }

#+END_SRC
	    	gene_map[0] = (1023, 1041)
	    	gene_map[1] = (900, 930)
		...

** 2.1 Generating mRNA:

	    This phase consists in substituting all T bases by a U base.

	    DNA	              :       ATGGGCCATTAATTTAAACGCACGGCGCCGCGCGGGTATGG
	    mRNA      	      :       AUGGGCCAUUAAUUUAAACGCACGGCGCCGCGCGGGUAUGG

	    The mRNA should only be computed for genes and must be kept alongside the original sequence.

#+BEGIN_SRC c

Algorithm:
  
   for (unsigned long long i = 0; i < seq_len; i++)
      if (seq[i] == 'T')
        seq[i] = 'U';

#+END_SRC

** 2.2 Generating an amino acid chain (protein):

	    From a given gene sequence, the program must generate a protein.

	    For example:
	    
	      Original mRNA sequence	    :	    AUG CGG CUG GCA GGU GUC GUC GAG CUU UGG

	      Protein (short names)	    :	    Met Arg Leu Ala Gly Val Val Glu Leu [Stop]

	      Protein (symbol)		    :	    M	R   L	A   G	V   V	E   L	

** 2.3 Detecting probable mutation zones:

	    A DNA sequence appears in nature as a double helix (3' - 5' and 5' - 3') of two complementary sequences:


	        Z0             Z1       Z2
	    3' ....	      ... ..............    5'
	    ATGGGCCATTAATTTAAACGCACGGCGCCGCGCGGGTATGG
	    TACCCGGTAATTAAATTTGCGTGCCGCGGCGCGCCCATACC
	    5'					    3'

	    In their paper, Kiktev & al. demonstrated that sequences with high GC content are more prone to mutations (base deletions, as well as
	    substitutions) than sequences with low GC content.

	    You're going to have to design an algorithm that analyses all the previously detected genes to locate mutation zones within a gene
	    (i.e. Z0, Z1, and Z2).
	    
** 2.4 Calculating the matching rate of two sequences

	    The matching rate between two sequences can be calculated using the Hamming distance of the two sequences.
	    The Hamming distance is calculated by performing a popcount on the output of the xor of the two sequences.

	    In other words:

#+BEGIN_EXAMPLE

Bits 0123456789....
S0:  0100101010010010
S1:  0101101000010110 xor
     --------------------
     0001000010000100 = x

     Hamming distance = popcount(x) = 3
 
     16 bits -> 100%
     3  bits -> y%

     y = 300/16 = 18.75% difference between S0 and S1.

     S0 and S1 have a 72.25% match.

#+END_EXAMPLE


#+BEGIN_SRC c

   for (i = 0; i < min(lengt(seq0), lenghth(seq1)); i++)
      d += popcount(seq0[i] xor seq1[i]);
	    
#+END_SRC

	    With d holding the Hamming distance at the end of the loop.

	    For example:
	    
	    S0: ATGCCCGGTATTAAATTT
	    S1: ATGCCCGGTATTAAATTT

	    The matching is 100%

	    _For example_:
	    
	    Genome sequence: ATGCCCGGTATTAAATTT...
	    Target sequence: ATGCCC

	    The matching rate is calculeted for each one of the steps below:
	    
	    ATGCCCGGTATTAAATTT;  diff = 0
	    ATGCCC
	    
	    ATGCCCGGTATTAAATTT;  diff = 4
	     ATGCCC

	    ATGCCCGGTATTAAATTT;  diff = 5
	      ATGCCC

	    ATGCCCGGTATTAAATTT;  diff = 11;
	       ATGCCC
